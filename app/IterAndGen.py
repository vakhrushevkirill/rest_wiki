# Что такое итераторы и генераторы?
# Отвечая на этот вопрос, разберемся что такое вообще итерирование. Итерирование, в контексте метаматематики, это выполнение какой-либо функции, вычисление результата которой используется результат предыдущего выполнения данной функции. Наиболее удачный и наглядный пример можно привести, демонстрирую вычисление последовательность чисел Фибоначчи, в которой первые два числа равны либо 0 и 1, либо 1 и 1, а каждое последующее число равно сумме двух предыдущих чисел.
# То есть F(0,n) = 0, 1, 1, 2, 3, 5, 8, ... F(F(n-2)+F(n-1))
# Используя язык программирования, в нашем случае Python, подобное вычисление можно представить в следующем виде
def fibonachi(n):
    if n == 0:
        return [0]
    elif n == 1:
        return [0, 1]
    else:
        fibo = [0, 1]
        index = 2
        while index < n:
            fibo.append(
                fibo[index-2] + fibo[index - 1]
            )
            index += 1
        return fibo

print(fibonachi(10))

# Замечу так же, что данное выражение является рекурсивным, но это не является предметом нашего вопроса
# В контексте же программирования, итерирование можно определить, как процесс просмотра набора данных отложено, то есть по одному за раз. Типичный пример обход списка в цикле. Итератор же, как объект, следует представлять как курсор на очередной элемент последовательности.
# Собственно говоря, паттерн Итератор уже в строен в язык программирования Python и используется для поддержки практически всех коллекций.
# Один из способов реализовать паттерн Итератор, это использование функции iter()
# Попробуем его реализовать.

# this_iterator = iter([1,2,3,4,5,6,7,11,10])
# print(next(this_iterator))
# print(next(this_iterator))
# print(next(this_iterator))
# print(next(this_iterator))
# while True:
#     print(next(this_iterator))

# Вызвав функцию next() мы получаем очередной элемент последовательности, до тех пор пока next не возбудит исключение StopIteration
# 1
# 2
# 3
# 4
# 6
# 8
# Traceback (most recent call last):
#   File "IterAndGen.py", line 32, in <module>
#     print(next(this_iterator))
# StopIteration

# Подводя итоги, можно с уверенностью утверждать, что итератором является любой объект, чей интерфейс реализует протокол итерации, переопределяя iter и next. 
# Сделаем это на примере той же последовательности Фибоначчи

class Fibonachi:
    def __init__(self, n):
        self.n = n
        self.before = 0
        self.current = 0
        self.index = 0
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.index < self.n:
            if self.index == 0:
                self.index += 1
                return self.current
            elif self.index == 1:
                self.current = self.before + 1
                self.index += 1
                return self.current
            else:
                before = self.before
                self.before = self.current
                self.current = before + self.current
                self.index += 1
                return self.current
        else:
            raise StopIteration
            

f = Fibonachi(10)
while True:
    try:
        print(next(f))
    except StopIteration:
        print('Все')
        break

# Как мы видим, результат как функции fibonachi так и экземпляра класса Fibonachi одинаков, но реализация класса Fibonachi выглядит чуть сложнее. Зачем же нам это нужно?
# Вызывая функцию fibonachi для 10 первых чисел мы создаем список длиною в 10 элементов. Кажется не много, но что если чисел будет 1000, 10^1000 или googol? Ответ прост: мы рано или поздно исчерпаем память компьютера. Затраты память при подобном подходе составят O(n), то есть количество затрачиваемой памяти будет равняться количеству элементов последовательности
# Но где мы выигрываем используя класс Fibonachi, реализующий протокол итератора?
# Вне зависимости от количества чисел, которые мы хотим получить, в памяти будет храниться только четыре значения: 
# 1) Количество чисел ряда Фибоначчи, которое мы хотим получить
# 2) Предшествующее число
# 3) Текущее число
# 4) Индекс итератора
# Затраты памяти при подобной реализации составят O(1), что очень и очень здорово!!!

# На этой приятной ноте мы плавно переходим к следующему предмету нашего вопроса. Генераторы.
# Как можно раскрыть понятие генератора? В какую область знаний мы бы не заглянули, везде увидим что генератор что то генерирует, иначе говоря производит. Углубимся в наши суждения. Производство чего либо конкретного происходит строго по одному и тому же рабочему процессу. 
# Подтвердим эту идею на базе генератора списков языка программирования Python. 
# Возьмем диапазон чисел от 0 до 9 и взведем эти числа в степень 2.
x=[y*y for y in range(10)]
print(x)

# Интересный момент. Функция range так же является по сути своей генератором последовательности, в нашем случае последовательность от 0 до 9.
# Перепишем этот генератор в более традиционный вид.
x = []
for y in range(10):
    x.append(y*y)
print(x)

# Одна строка против трех. Экономия сил на написание кода на лицо. А экономим ли мы время выполнения? Проверим это для 100000 чисел.

import time
time_start = time.time()
x=[y*y for y in range(100000)]
print('Генератор выполнился за время:', time.time() - time_start)

time_start = time.time()
x = []
for y in range(10):
    x.append(y*y)
print('Цикл выполнился за время:', time.time() - time_start)

# В моем случае время вышло следующим.
# Генератор выполнился за время: 0.02001190185546875
# Цикл выполнился за время: 0.002711057662963867
# Как видно генератор списка дал небольшой, но все же выйгрыш по времени выполнения.
# Заглянем теперь за кулисы генераторов, и попробуем создать свой генератор чисел Фибоначчи используя ключевое слово "yield".
def fibonachi_gen(n):
    before = 0
    current = 1
    index = 0
    while index < n:
        if index == 0:
            yield 0
            index += 1
        elif index == 1:
            yield 1
            index += 1
        else:
            t_before = current
            current = current + before
            before = t_before
            yield current
            index += 1

for x in fibonachi_gen(10):
    print(x)

# Или же
fibo_gen = fibonachi_gen(10)
print(next(fibo_gen))
print(next(fibo_gen))
print(next(fibo_gen))

# Или же
fibo_gen = [x for x in fibonachi_gen(10)]
print(fibo_gen)

# Что же такое yield? Yield по сути своей является синтаксическим сахаром, заменяя собой возврат return, с тем отличием что yield позволяет заморозить состояние вызываемого объекта, ожидая когда его вызовут функцией next().
# Исходя из вышеизложенного вывод очевиден. Генератор является частным случаем итератора. Более того, созданный нами ранее класс Fibonachi так же является генератором. Но является ли каждый итератор генератором?
# Вспомним определение итерирования. Итерирование это процесс, позволяющий работать над элементами последовательности по одному за раз. То есть основной идеей итерирования является последовательное влияние на некую последовательность, поэлементно, инкапсулируя внутренние процессы и саму последовательность.
# Генератор же, в свою очередь, с коллекциями явных дел не имеет (хотя и предполагает их абстрактное существование), а использует в очередной итерации результаты предыдущей. 
# Подводя итоги можно с уверенностью утверждать что итераторы мы используем всегда, работая с коллекциями, обходя их в цикле последовательно, потому что, как вы могли заметить объект-итератор, при работе с циклом for всегда создается неявно. Генераторы же, в свою очередь, позволяют нам обходить коллекции не заботясь о всех предыдущих результатах. Хорошим примером может служить обход базы данных, когда для работы с полями таблицы мы храним только индекс, тем самым не вытаскивая всю таблицу в рабочую память, а использую только текущее поле, соответствующее хранимому индексу.